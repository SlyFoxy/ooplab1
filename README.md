# ТЕХНІЧНЕ ЗАВДАННЯ
## Назва проекту: Система автоматизації процесів замовлень та обслуговування ресторану "GourmetFlow"
## 1. Вступ
Ресторанний бізнес вимагає ефективного управління численними процесами, від прийому замовлень та їх передачі на кухню до розрахунку клієнтів та управління програмами лояльності. Метою даного проекту є розробка програмної системи "GourmetFlow", яка автоматизує ключові аспекти роботи ресторану, підвищуючи ефективність персоналу, якість обслуговування та задоволеність клієнтів. Система повинна бути гнучкою для адаптації до різних операційних моделей та майбутніх розширень, при цьому її архітектура має базуватися на перевірених об'єктно-орієнтованих патернах проектування.
## 2. Мета
Створити комплексну програмну систему "GourmetFlow" для автоматизації процесів прийому, обробки, виконання та оплати замовлень у ресторані. Система повинна забезпечувати функціонал для управління меню та стравами, гнучкого ціноутворення, відстеження стану замовлень, взаємодії персоналу, інтеграції з платіжними системами, а також кастомізації обслуговування. Ключовою вимогою є реалізація зазначених функціональних блоків з обов'язковим застосуванням визначених патернів проектування для забезпечення високої якості, гнучкості та підтримуваності архітектури.
## 3. Деталізація Реалізації Патернів Проектування
### У цьому розділі детально розглядається кожен патерн проектування, застосований у системі, його роль та особливості реалізації.
## 3.1. Породжуючі Патерни (Creational Patterns)
### 3.1.1. Фабричний Метод (Factory Method) та Абстрактна Фабрика (Abstract Factory)
- Призначення в системі: Забезпечення гнучкого створення об'єктів страв (Dish) різних типів (Pizza, Pasta) без прив'язки клієнтського коду до конкретних класів страв.

Архітектурне рішення:
- Визначено абстрактний клас DishFactory з абстрактним методом CreateDish(). Цей клас виступає в ролі Абстрактної Фабрики, що визначає інтерфейс для створення продуктів (страв).
- Створено конкретні класи-фабрики PizzaFactory та PastaFactory, що успадковуються від DishFactory та реалізують метод CreateDish() (Фабричний метод) для створення екземплярів Pizza та Pasta відповідно.

Деталі реалізації:
- Клієнтський код (наприклад, в Program.Main або інших сервісах) використовує конкретні фабрики для отримання об'єктів страв, не знаючи про процес їх створення.
- Dish: Абстрактний клас для страви.
- Pizza, Pasta: Конкретні класи страв.
- Обґрунтування вибору: Дозволяє легко додавати нові типи страв та відповідні фабрики без модифікації існуючого клієнтського коду, що використовує фабрики. Спрощує управління створенням об'єктів.
### 3.1.2. Прототип (Prototype)
- Призначення в системі: Надання можливості ефективного створення нових об'єктів замовлень (Order) шляхом копіювання існуючих екземплярів.

Архітектурне рішення:
- Інтерфейс ICloneableOrder визначає метод Clone().
- Клас Order реалізує ICloneableOrder та надає конкретну реалізацію методу Clone().

Деталі реалізації:
- Метод Order.Clone() створює новий екземпляр Order та копіює значення його властивостей (наприклад, BasePrice, PricingStrategy).
- Для колекцій, таких як Dishes (список страв), виконується глибоке копіювання (створюється новий список з копіями елементів або посиланнями, якщо елементи незмінні), щоб уникнути спільного використання змінюваних даних між оригіналом та клоном.
- Обґрунтування вибору: Зменшує витрати на створення об'єктів, особливо якщо їх ініціалізація є складною. Дозволяє створювати об'єкти з певним початковим станом без повторного проходження всіх етапів конструювання.
### 3.1.3. Будівельник (Builder)
- Призначення в системі: Забезпечення покрокового конструювання складних об'єктів Order, особливо для створення стандартизованих наборів (наприклад, комбо-меню).

Архітектурне рішення:
- Інтерфейс IOrderBuilder визначає кроки для конструювання замовлення (наприклад, AddDish(), Build()).
- Клас OrderBuilder є конкретною реалізацією будівельника, що акумулює частини замовлення та повертає готовий об'єкт.
- Клас Director (опціональний, але присутній у реалізації) використовує IOrderBuilder для конструювання певного типу замовлення (наприклад, CreateComboMeal()), керуючи послідовністю кроків.

Деталі реалізації:
- OrderBuilder всередині створює та налаштовує екземпляр Order.
- Метод Build() повертає сконструйований Order.
- Обґрунтування вибору: Дозволяє створювати об'єкти з великою кількістю опціональних параметрів або складною логікою конструювання, роблячи код створення більш читабельним та гнучким. Відокремлює процес конструювання від представлення об'єкта.
## 3.2. Структурні Патерни (Structural Patterns)
### 3.2.1. Адаптер (Adapter)
- Призначення в системі: Інтеграція зовнішньої платіжної системи (ExternalPaymentService) з існуючим інтерфейсом системи IPaymentSystem.

Архітектурне рішення:
- Інтерфейс IPaymentSystem визначає цільовий інтерфейс, який очікує система.
- Клас ExternalPaymentService представляє зовнішній сервіс з несумісним інтерфейсом (наприклад, метод MakePayment(double amount)).
- Клас PaymentAdapter реалізує IPaymentSystem та інкапсулює екземпляр ExternalPaymentService. Метод ProcessPayment(decimal amount) адаптера викликає відповідний метод зовнішнього сервісу, виконуючи необхідні перетворення типів (наприклад, decimal в double).
- Обґрунтування вибору: Дозволяє повторно використовувати існуючі класи з несумісними інтерфейсами, не змінюючи їх вихідний код.
### 3.2.2. Міст (Bridge)
- Призначення в системі: Відокремлення абстракції "страва, що подається" від реалізації "стилю подачі", дозволяючи їм змінюватися незалежно.

Архітектурне рішення:
- Абстракція: ServableDish (абстрактний клас) містить посилання на інтерфейс реалізації (IDishServingStyle) та делегує йому частину роботи. PreparedPizza та PreparedPasta є уточненими абстракціями.
- Реалізація: IDishServingStyle (інтерфейс Implementor) визначає операції для стилів подачі. DineInServingStyle та TakeAwayServingStyle є конкретними реалізаціями.

Деталі реалізації:
- ServableDish у конструкторі приймає конкретну страву (Dish) та стиль подачі (IDishServingStyle).
- Метод PresentDish() в ServableDish (або його нащадках) викликає методи об'єкта стилю подачі.
- Обґрунтування вибору: Збільшує гнучкість системи, дозволяючи комбінувати різні типи страв з різними стилями подачі без створення великої кількості підкласів. Спрощує розширення як ієрархії страв, так і ієрархії стилів подачі.
### 3.2.3. Фасад (Facade)
- Призначення в системі: Надання спрощеного та уніфікованого інтерфейсу до складної підсистеми управління замовленнями та пов'язаними операціями.

Архітектурне рішення:
- Клас RestaurantFacade інкапсулює взаємодію з різними компонентами: Order, IPaymentSystem (через PaymentAdapter), KitchenMediator (для координації з кухнею), фабриками страв тощо.
- Надає високорівневі методи (AddDishToOrder, PlaceAndPayOrder, OrderComboMealAndPay), які приховують від клієнта деталі взаємодії цих компонентів.
- Обґрунтування вибору: Зменшує складність використання підсистеми для клієнтського коду. Послаблює зв'язність між клієнтом та компонентами підсистеми.
### 3.2.4. Замісник (Proxy)
- Призначення в системі: Контроль доступу до сервісу приготування спеціальних страв (RealCookingService) та лінива ініціалізація цього сервісу.

Архітектурне рішення:
- Інтерфейс ICookingService визначає спільний інтерфейс для реального сервісу та замісника.
- Клас RealCookingService виконує основну (потенційно "важку" або захищену) роботу.
- Клас CookingServiceProxy реалізує ICookingService, містить посилання на RealCookingService. Перед делегуванням запиту реальному сервісу, замісник виконує перевірку прав доступу (наприклад, чи може користувач замовити "секретну страву"). RealCookingService створюється лише при першому успішному запиті, що вимагає його використання.
- Обґрунтування вибору: Дозволяє додати додаткову логіку (контроль доступу, логування, кешування, лінива ініціалізація) до операцій об'єкта, не змінюючи сам об'єкт.
## 3.3. Поведінкові Патерни (Behavioral Patterns)
### 3.3.1. Ланцюжок Обов'язків (Chain of Responsibility)
- Призначення в системі: Обробка скарг клієнтів шляхом передачі запиту послідовно по ланцюжку обробників доти, доки один з них не обробить запит.

Архітектурне рішення:
- Абстрактний клас ComplaintHandler визначає інтерфейс обробника та містить посилання на наступного обробника (_nextHandler).
- Конкретні класи обробників (ManagerHandler, ChefHandler, DiscountHandler) реалізують логіку обробки певного типу скарг. Якщо обробник не може обробити скаргу, він передає її наступному в ланцюжку.
- Обґрунтування вибору: Зменшує зв'язність між відправником запиту та його отримувачами. Дозволяє динамічно змінювати склад ланцюжка.
### 3.3.2. Команда (Command)
- Призначення в системі: Інкапсуляція запитів на виконання дій (наприклад, додавання страви до замовлення) як об'єктів, що дозволяє їх параметризувати, ставити в чергу, логувати та реалізовувати операції скасування.

Архітектурне рішення:
- Інтерфейс ICommand визначає методи Execute() та Undo().
- Клас AddDishCommand є конкретною командою, що зберігає посилання на отримувача (Order) та параметри дії (назва страви).
- Обґрунтування вибору: Дозволяє відокремити об'єкт, що ініціює операцію, від об'єкта, що її виконує. Полегшує реалізацію функціоналу скасування/повтору дій.
### 3.3.3. Інтерпретатор (Interpreter)
- Призначення в системі: Обробка простих текстових команд користувача для управління замовленнями.

Архітектурне рішення:
- Інтерфейс IExpression визначає метод Interpret(Order order).
- Класи AddDishExpression та RemoveDishExpression реалізують конкретні команди (термінальні вирази).
- Клас InterpreterContext відповідає за парсинг вхідного рядка та створення відповідного об'єкта-виразу.
- Обґрунтування вибору: Дозволяє легко визначати та інтерпретувати прості мови. Корисний для реалізації конфігураційних файлів або простих скриптових мов.
### 3.3.4. Ітератор (Iterator)
- Призначення в системі: Надання стандартизованого способу послідовного доступу до елементів колекції замовлень (OrderCollection) без розкриття її внутрішньої структури.

Архітектурне рішення:
- Інтерфейс IOrderIterator визначає методи для обходу колекції (HasNext(), Next()).
- Клас OrderIterator реалізує цей інтерфейс для конкретної колекції List<Order>.
- Клас OrderCollection надає метод CreateIterator() для отримання екземпляра ітератора.
- Обґрунтування вибору: Уніфікує інтерфейс для обходу різних типів колекцій. Приховує деталі реалізації колекції від клієнтського коду.
### 3.3.5. Посередник (Mediator)
- Призначення в системі: Централізація та управління взаємодією між різними компонентами системи (Офіціант, Кухар) для зменшення їх прямої зв'язності.

Архітектурне рішення:
- Інтерфейс IMediator визначає метод Notify() для сповіщення посередника про події.
- Клас KitchenMediator є конкретним посередником, який знає про Офіціанта (WaiterMediator) та Кухаря (ChefMediator) і координує їх взаємодію (наприклад, передає нове замовлення від офіціанта кухарю, а повідомлення про готовність – від кухаря офіціанту).
- Класи WaiterMediator та ChefMediator (Колеги) взаємодіють тільки з KitchenMediator, а не один з одним напряму.
- Обґрунтування вибору: Спрощує взаємозв'язки в системі, де багато об'єктів повинні взаємодіяти один з одним. Зміни в логіці взаємодії локалізуються в посереднику.
### 3.3.6. Зберігач (Memento)
- Призначення в системі: Забезпечення можливості збереження та відновлення стану об'єкта Order без порушення його інкапсуляції.

Архітектурне рішення:
- Клас Order (Originator) створює об'єкт OrderMemento та відновлює свій стан з нього.
- Клас OrderMemento (Memento) зберігає стан Order (список страв, стратегію ціноутворення, базову ціну).
- Клас OrderCaretaker (Caretaker) відповідає за збереження та надання доступу до об'єктів Memento, не знаючи їх внутрішньої структури. Використовує стек для реалізації "undo".
- Обґрунтування вибору: Дозволяє реалізувати функціонал скасування дій або збереження проміжних станів об'єкта, не розкриваючи його внутрішні деталі.
### 3.3.7. Спостерігач (Observer)
- Призначення в системі: Автоматичне сповіщення залежних об'єктів (Офіціант Waiter, Кухар Chef) про зміни в стані об'єкта Order (наприклад, додавання нової страви).

Архітектурне рішення:
- Клас Order (Subject/Видавець) містить екземпляр OrderNotifier.
- OrderNotifier управляє списком підписників (Спостерігачів) та викликає їх метод Update() при отриманні сповіщення від Order.
- Інтерфейс IOrderObserver визначає метод Update(Order order).
- Класи Waiter та Chef реалізують IOrderObserver.
- Обґрунтування вибору: Забезпечує слабку зв'язність між об'єктом, що генерує події, та об'єктами, що на них реагують. Полегшує додавання нових спостерігачів.
### 3.3.8. Стан (State)
- Призначення в системі: Управління поведінкою об'єкта OrderContext (що представляє замовлення) залежно від його внутрішнього стану (Очікування, Приготування, Готове, Доставлено).
  Архітектурне рішення:
- Інтерфейс IOrderState визначає методи, спільні для всіх станів (NextState(), PrintStatus()).
- Конкретні класи станів (PendingState, CookingState, ReadyState, DeliveredState) реалізують поведінку, специфічну для кожного стану, та логіку переходу до наступного стану.
- Клас OrderContext зберігає посилання на поточний об'єкт-стан та делегує йому виконання операцій.
- Обґрунтування вибору: Дозволяє об'єкту змінювати свою поведінку при зміні внутрішнього стану, ніби об'єкт змінює свій клас. Інкапсулює поведінку, пов'язану зі станом, в окремі класи.
### 3.3.9. Стратегія (Strategy)
- Призначення в системі: Надання можливості динамічно змінювати алгоритм розрахунку ціни замовлення.

Архітектурне рішення:
- Інтерфейс IPricingStrategy визначає загальний інтерфейс для всіх алгоритмів ціноутворення.
- Конкретні класи стратегій (RegularPricing, DiscountPricing, PremiumPricing) реалізують різні алгоритми розрахунку ціни.
- Клас Order містить посилання на об'єкт IPricingStrategy та використовує його для розрахунку фінальної ціни.
- Обґрунтування вибору: Інкапсулює сімейство алгоритмів, роблячи їх взаємозамінними. Дозволяє змінювати алгоритми незалежно від клієнтського коду, що їх використовує.
### 3.3.10. Відвідувач (Visitor)
- Призначення в системі: Додавання нових операцій до ієрархії класів страв (Dish, Pizza, Pasta) без модифікації самих цих класів (наприклад, виведення інформації, перевірка калорійності).

Архітектурне рішення:
- Інтерфейс IDishVisitor визначає методи Visit...() для кожного конкретного типу страви.
- Конкретні класи відвідувачів (DishInfoVisitor, CalorieCheckVisitor) реалізують операції для кожного типу страви.
- Абстрактний клас Dish та його нащадки Pizza, Pasta (Елементи) визначають метод Accept(IDishVisitor visitor), який викликає відповідний метод Visit...() у переданого відвідувача (подвійна диспетчеризація).
- Обґрунтування вибору: Дозволяє легко додавати нові операції до стабільної ієрархії класів. Збирає пов'язану логіку в одному місці (класі відвідувача).
## 4. Вимоги до Системи
### 4.1. Функціональні Вимоги:
- Створення та управління замовленнями (додавання/видалення страв, зміна кількості).
- Розрахунок вартості замовлень з урахуванням різних цінових політик.
- Відстеження та зміна статусів замовлень.
- Обробка платежів через інтегровану систему.
- Управління меню ресторану.
- Обробка скарг та запитів клієнтів.
- Забезпечення різних стилів подачі страв.
- Можливість скасування операцій та збереження/відновлення стану замовлень.
- Контроль доступу до певних функцій та страв.
- Виконання адміністративних завдань через текстові команди.
## 5. Очікувані Результати
- Розроблена програмна система "GourmetFlow", що повністю реалізує функціонал, описаний у розділі 2 "Мета та Завдання Проекту", з чітким та коректним застосуванням усіх зазначених патернів проектування.
- Консольний додаток, що дозволяє продемонструвати роботу кожного реалізованого патерну в контексті виконання відповідних бізнес-завдань системи.
- Вихідний код, що відповідає вимогам до архітектури та реалізації.
