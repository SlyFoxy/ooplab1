# Проєктування та реалізація програмної системи управління замовленнями в ресторані
## Мета: Розробити програмну систему, що дозволяє створювати та обробляти замовлення в ресторані, використовуючи шаблони проєктування: Фабричний метод, Абстрактна фабрика, Прототип, Будівельник, Стратегія, Спостерігач, Команда, Адаптер, Фасад, Стан, Макрокоманди, Шаблонний метод, Ітератор, Ланцюжок обов'язків, Інтерпретатор, Посередник, Зберігач, Відвідувач, Замісник та Міст.
## Функціональні вимоги:
### Створення замовлень:
- Користувач має можливість створювати замовлення, додаючи до нього різні страви.
- Використання Фабричного методу та Абстрактної фабрики для створення об'єктів страв (піца, паста тощо).
### Керування замовленнями:
- Додавання та видалення страв у замовленні.
- Використання патерна Прототип для можливості копіювання замовлення.
- Використання Будівельника для створення комплексних замовлень (наприклад, комбо-меню).
- Використання патерна Зберігач (Memento) для можливості збереження та відновлення стану замовлення (наприклад, для реалізації функції "скасувати" на рівні всього замовлення).
### Обробка та представлення страв:
- Використання патерна Відвідувач для додавання нових операцій до страв (наприклад, виведення детальної інформації, перевірка калорійності) без зміни класів самих страв.
- Використання патерна Міст для відокремлення абстракції страви, що подається, від конкретного стилю її подачі (наприклад, подача в залі ресторану або на виніс), дозволяючи їм змінюватися незалежно.
### Ціноутворення:
- Реалізація різних стратегій розрахунку ціни (звичайна, зі знижкою, преміум) за допомогою патерна Стратегія.
### Робота з командами:
- Використання патерна Команда для можливості скасування останньої дії (додавання або видалення страви).
### Оплата замовлення:
- Використання Адаптера для інтеграції зовнішньої платіжної системи.
- Спрощений інтерфейс управління замовленням:
- Використання Фасаду для спрощення процесу додавання страв та оплати замовлення.
### Контроль доступу та оптимізація:
- Використання патерна Замісник для контролю доступу до приготування спеціальних або "дорогих" страв, а також для лінивої ініціалізації ресурсномістких сервісів.
### Стани замовлення:
- Використання патерна Стан для управління етапами виконання замовлення (очікування, приготування, готове до видачі, доставлено).
### Нефункціональні вимоги:
- Система повинна бути розроблена мовою C#.
- Використання об'єктно-орієнтованого підходу та принципів SOLID.
- Код має бути структурований та легко підтримуваний.
- Використання шаблонів проєктування відповідно до їх призначення.
### Архітектура та взаємодія компонентів:
- Користувач взаємодіє із Фасадом, який забезпечує спрощений інтерфейс для створення замовлень та їх оплати.
- Фасад викликає відповідні фабрики для створення страв, додає їх у Замовлення.
- Замовлення використовує Стратегію для розрахунку ціни та Спостерігачів для повідомлення офіціантів і кухарів про зміни.
- Будівельник дозволяє створювати комбо-набори страв.
- Команда дозволяє скасовувати або повторювати операції додавання/видалення страв.
- Адаптер забезпечує взаємодію з зовнішньою платіжною системою при оплаті замовлення.
- Контекст стану керує етапами виконання замовлення (очікування, приготування, видача, доставка).
- Макрокоманди дозволяють об'єднувати кілька операцій у одну, спрощуючи управління комплексними замовленнями, наприклад, автоматичне додавання кількох страв до замовлення.
- Шаблонний метод задає стандартний алгоритм обробки замовлення, де конкретні етапи (підготовка страв, обробка оплати тощо) деталізуються в підкласах, дозволяючи стандартизувати процес, але залишаючи можливість змінювати деталі реалізації.
- Ітератор дозволяє зручно працювати зі списком замовлень.
- Ланцюжок обов’язків дозволяє передавати скарги по вертикалі (менеджер → шеф → знижка).
- Інтерпретатор обробляє команди у вигляді тексту.
- Посередник узгоджує дії між компонентами (офіціант, кухня).
- Зберігач дозволяє фіксувати та відновлювати стан об'єкта Order через OrderCaretaker, не порушуючи інкапсуляцію Order.
- Відвідувач додає нові операції до ієрархії класів Dish (та його нащадків Pizza, Pasta), дозволяючи, наприклад, DishInfoVisitor або CalorieCheckVisitor обробляти страви без зміни їхнього коду.
- Замісник контролює доступ до RealCookingService через CookingServiceProxy, перевіряючи права користувача та керуючи створенням реального сервісу.
- Міст відокремлює абстракцію ServableDish від реалізацій стилів подачі (IDishServingStyle та її конкретні класи), дозволяючи динамічно комбінувати різні страви з різними способами подачі.
## Результат виконання:
- Реалізований консольний додаток, що демонструє роботу всіх перелічених шаблонів проєктування.
- Тестування основних функцій (створення замовлення, додавання/видалення страв, оплата, зміна стану тощо).
